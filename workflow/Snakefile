import pandas as pd
import os
import sys

p = os.getcwd()
sys.path.append(p)

from utils import *

include: 'download.smk'
configfile: 'workflow/config.yml'

# ccre stuff
# ccre_df = pd.read_csv('workflow/ccre_config.tsv', sep='\t')
ccre_df = pd.read_csv('workflow/ccre_config.tsv', sep='\t')
ccre_types = ccre_df.ccre_type.unique().tolist()
species = ccre_df.species.unique().tolist()

# procap stuff
procap_meta = process_encode_metadata('workflow/procap_metadata.tsv')

# lr stuff
lr_df = pd.read_csv('workflow/lr_config.tsv', sep='\t')
lr_meta = process_encode_metadata(expand(config['lr']['encode_meta'], species='human')[0])


wildcard_constraints:
    pc_biosamp='|'.join([re.escape(x) for x in procap_meta.biosamp.tolist()]),
    pc_rep='|'.join([re.escape(x) for x in procap_meta.biorep.astype(str).tolist()]),
    pc_output='|'.join([re.escape(x) for x in procap_meta.output.tolist()]),

rule all:
    input:
        expand(config['ccre']['bed'],
               species=species,
               ccre_type=ccre_types),
        expand(config['procap']['bed_format'],
               zip,
               pc_biosamp=procap_meta.biosamp.tolist(),
               pc_rep=procap_meta.biorep.tolist(),
               pc_output=procap_meta.output.tolist()),
        expand(expand(config['lr']['bed'],
               zip,
               lr_biosamp=lr_meta.biosamp.tolist(),
               lr_rep=lr_meta.biorep.tolist(),
               allow_missing=True),
               species='human')

################################################################################
########################### cCRE download ######################################
################################################################################
def get_ccre_link(wc, ccre_df):
    temp = ccre_df.copy(deep=True)
    return ccre_df.loc[(ccre_df.species==wc.species)&\
                       (ccre_df.ccre_type==wc.ccre_type), 'link'].values[0]

use rule dl as dl_ccre with:
    params:
        link = lambda wc:get_ccre_link(wc, ccre_df)
    output:
        out = temporary(config['ccre']['bed_gz'])

use rule gunzip as gunzip_ccre with:
    input:
        gz = config['ccre']['bed_gz']
    output:
        out = config['ccre']['bed']

################################################################################
########################## ProCap download #####################################
################################################################################
def get_procap_encid(wc, df):
    output_type = wc.pc_output
    biosamp = wc.pc_biosamp
    rep = int(wc.pc_rep)
    temp = df.loc[(df.biosamp==biosamp)&\
                  (df.biorep==rep)&\
                  (df['output']==output_type)]
    return temp['File accession'].values[0]

use rule dl_encid_bed as dl_encid_procap_bed with:
    params:
        encid = lambda wc:get_procap_encid(wc, procap_meta)
    output:
        bed = config['procap']['bed_gz']

use rule gunzip as gunzip_procap with:
    input:
        gz = config['procap']['bed_gz']
    output:
        out = config['procap']['bed']

rule procap_format:
    input:
        bed = config['procap']['bed']
    resources:
        mem_gb = 10,
        threads = 1
    output:
        bed = config['procap']['bed_format']
    run:
        df = pd.read_csv(input.bed, sep='\t',
                         header=None,
                         names=['Chromosome', 'Start','End'], usecols=[0,1,2])
        pr.PyRanges(df).to_bed(output.bed)

################################################################################
####################### LR TSS download / proc #################################
################################################################################
def get_lr_link(wc, df, type):
    temp = df.copy(deep=True)
    return df.loc[(df.species==wc.species)&\
                  (df.output_type==type), 'link'].values[0]

use rule dl as dl_lr_ca with:
    params:
        link = lambda wc:get_lr_link(wc, lr_df, 'ca')
    output:
        # out = temporary(config['lr']['ca'])
        out = config['lr']['ca']


use rule dl as dl_lr_meta with:
    params:
        link = lambda wc:get_lr_link(wc, lr_df, 'metadata')
    output:
        # out = temporary(config['lr']['meta'])
        out = config['lr']['meta']

use rule dl as dl_lr_filt_ab with:
    params:
        link = lambda wc:get_lr_link(wc, lr_df, 'filt_ab')
    output:
        # out = temporary(config['lr']['filt_ab'])
        out = config['lr']['filt_ab']

rule get_lr_det_mat:
    input:
        meta = config['lr']['meta'],
        enc_meta = config['lr']['encode_meta'],
        filt_ab = config['lr']['filt_ab']
    resources:
        threads = 4,
        mem_gb = 16
    params:
        min_tpm = 1
    output:
        det_mat = config['lr']['det_mat']
    run:
        get_det_table(input.meta,
                      input.enc_meta,
                      input.filt_ab,
                      params.min_tpm,
                      output.det_mat)

rule get_lr_bed:
    input:
        ca_h5 = config['lr']['ca'],
        det_mat = config['lr']['det_mat']
    resources:
        threads = 2,
        mem_gb = 16
    output:
        bed = config['lr']['bed']
    run:
        get_lr_tss(input.ca_h5,
                   input.det_mat,
                   wildcards.lr_biosamp,
                   wildcards.lr_rep,
                   output.bed)
