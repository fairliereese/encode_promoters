import pandas as pd
import os
import sys
import numpy as np

p = os.getcwd()
sys.path.append(p)

from utils import *

include: 'download.smk'
configfile: 'workflow/config.yml'

# ccre stuff
# ccre_df = pd.read_csv('workflow/ccre_config.tsv', sep='\t')
ccre_df = pd.read_csv('workflow/ccre_config.tsv', sep='\t')
ccre_types = ccre_df.ccre_type.unique().tolist()
species = ccre_df.species.unique().tolist()
species = 'human'

# procap stuff
procap_meta = process_encode_metadata(config['procap']['encode_meta'])

# lr stuff
lr_df = pd.read_csv('workflow/lr_config.tsv', sep='\t')
lr_meta = process_encode_metadata(expand(config['lr']['encode_meta'], species='human')[0])

# h3k4me3 chip stuff
h3_df = process_encode_metadata(config['h3k4me3']['encode_meta'])

wildcard_constraints:
    ccre_type='|'.join([re.escape(x) for x in ccre_types]),
    pc_biosamp='|'.join([re.escape(x) for x in procap_meta.biosamp.tolist()]),
    pc_rep='|'.join([re.escape(x) for x in procap_meta.biorep.astype(str).tolist()]),
    pc_output='|'.join([re.escape(x) for x in procap_meta.output.tolist()]),
    lr_biosamp='|'.join([re.escape(x) for x in lr_meta.biosamp.tolist()]),
    lr_rep='|'.join([re.escape(x) for x in lr_meta.biorep.astype(str).tolist()]),
    h3_biosamp='|'.join([re.escape(x) for x in h3_meta.biosamp.astype(str).tolist()]),


rule all:
    input:
        expand(config['ccre']['intersect'],
               species=species,
               ccre_type=ccre_types),
       expand(config['h3k4me3']['bed'],
              zip,
              pc_biosamp=h3_df.biosamp.tolist()),
        # expand(config['ccre']['bed'],
        #        species=species,
        #        ccre_type=ccre_types),
        # expand(config['procap']['bed_format'],
        #        zip,
        #        pc_biosamp=procap_meta.biosamp.tolist(),
        #        pc_rep=procap_meta.biorep.tolist(),
        #        pc_output=procap_meta.output.tolist()),
        # expand(expand(config['lr']['bed_format'],
        #        zip,
        #        lr_biosamp=lr_meta.biosamp.tolist(),
        #        lr_rep=lr_meta.biorep.tolist(),
        #        allow_missing=True),
        #        species='human')

################################################################################
########################### cCRE download ######################################
################################################################################
def get_ccre_link(wc, ccre_df):
    temp = ccre_df.copy(deep=True)
    return ccre_df.loc[(ccre_df.species==wc.species)&\
                       (ccre_df.ccre_type==wc.ccre_type), 'link'].values[0]

use rule dl as dl_ccre with:
    params:
        link = lambda wc:get_ccre_link(wc, ccre_df)
    output:
        out = temporary(config['ccre']['bed_gz'])

use rule gunzip as gunzip_ccre with:
    input:
        gz = config['ccre']['bed_gz']
    output:
        out = config['ccre']['bed']

################################################################################
########################## ProCap download #####################################
################################################################################
def get_procap_encid(wc, df):
    output_type = wc.pc_output
    biosamp = wc.pc_biosamp
    rep = int(wc.pc_rep)
    temp = df.loc[(df.biosamp==biosamp)&\
                  (df.biorep==rep)&\
                  (df['output']==output_type)]
    return temp['File accession'].values[0]

use rule dl_encid_bed as dl_encid_procap_bed with:
    params:
        encid = lambda wc:get_procap_encid(wc, procap_meta)
    output:
        bed = config['procap']['bed_gz']

use rule gunzip as gunzip_procap with:
    input:
        gz = config['procap']['bed_gz']
    output:
        out = config['procap']['bed']

rule procap_format:
    input:
        bed = config['procap']['bed']
    resources:
        mem_gb = 10,
        threads = 1
    output:
        bed = config['procap']['bed_format']
    run:
        df = pd.read_csv(input.bed, sep='\t',
                         header=None,
                         names=['Chromosome', 'Start','End'], usecols=[0,1,2])
        df['assay'] = 'procap'
        df['biosample'] = wildcards.pc_biosamp
        df['rep'] = wildcards.pc_rep
        df['output'] = wildcards.pc_output
        df.to_csv(output.bed, index=False, sep='\t')
        # pr.PyRanges(df).to_bed(output.bed)

################################################################################
####################### H3K4me3 download / proc ################################
################################################################################
def get_h3k4me3_encid(wc, df):
    biosamp = wc.pc_biosamp
    temp = df.loc[(df.biosamp==biosamp)]
    return temp['File accession'].values[0]

use rule dl_encid_bed as dl_encid_h3k4me3_bed with:
    params:
        encid = lambda wc:get_h3k4me3_encid(wc, h3_meta)
    output:
        bed = config['h3k4me3']['bed_gz']

use rule gunzip as gunzip_h3k4me3 with:
    input:
        gz = config['h3k4me3']['bed_gz']
    output:
        out = config['h3k4me3']['bed']

################################################################################
####################### LR TSS download / proc #################################
################################################################################
def get_lr_link(wc, df, type):
    temp = df.copy(deep=True)
    return df.loc[(df.species==wc.species)&\
                  (df.output_type==type), 'link'].values[0]

use rule dl as dl_lr_ca with:
    params:
        link = lambda wc:get_lr_link(wc, lr_df, 'ca')
    output:
        # out = temporary(config['lr']['ca'])
        out = config['lr']['ca']

use rule dl as dl_lr_meta with:
    params:
        link = lambda wc:get_lr_link(wc, lr_df, 'metadata')
    output:
        # out = temporary(config['lr']['meta'])
        out = config['lr']['meta']

use rule dl as dl_lr_filt_ab with:
    params:
        link = lambda wc:get_lr_link(wc, lr_df, 'filt_ab')
    output:
        # out = temporary(config['lr']['filt_ab'])
        out = config['lr']['filt_ab']

rule get_lr_det_mat:
    input:
        meta = config['lr']['meta'],
        enc_meta = config['lr']['encode_meta'],
        filt_ab = config['lr']['filt_ab']
    resources:
        threads = 4,
        mem_gb = 16
    params:
        min_tpm = 1
    output:
        det_mat = config['lr']['det_mat']
    run:
        get_det_table(input.meta,
                      input.enc_meta,
                      input.filt_ab,
                      params.min_tpm,
                      output.det_mat)

rule get_lr_bed:
    input:
        ca_h5 = config['lr']['ca'],
        det_mat = config['lr']['det_mat']
    resources:
        threads = 2,
        mem_gb = 16
    output:
        bed = config['lr']['bed']
    run:
        get_lr_tss(input.ca_h5,
                   input.det_mat,
                   wildcards.lr_biosamp,
                   wildcards.lr_rep,
                   output.bed)

rule lr_format:
   input:
       bed = config['lr']['bed']
   resources:
       mem_gb = 10,
       threads = 1
   output:
       bed = config['lr']['bed_format']
   run:
       df = pd.read_csv(input.bed, sep='\t',
                        header=None,
                        names=['Chromosome', 'Start','End'], usecols=[0,1,2])
       df['assay'] = 'lr'
       df['biosample'] = wildcards.lr_biosamp
       df['rep'] = wildcards.lr_rep
       df['output'] = np.nan
       df.to_csv(output.bed, index=False, sep='\t')

################################################################################
########################### cCRE intersect #####################################
################################################################################
def get_bed_files(wc):
    pc_files = expand(config['procap']['bed_format'],
           zip,
           pc_biosamp=procap_meta.biosamp.tolist(),
           pc_rep=procap_meta.biorep.tolist(),
           pc_output=procap_meta.output.tolist())
    lr_files = expand(expand(config['lr']['bed_format'],
           zip,
           lr_biosamp=lr_meta.biosamp.tolist(),
           lr_rep=lr_meta.biorep.tolist(),
           allow_missing=True),
           species=wc.species)
    files = pc_files+lr_files
    return files

rule ccre_intersect:
    input:
        ccre = config['ccre']['bed'],
        files = lambda wc:get_bed_files(wc)
    resources:
        mem_gb = 32,
        threads = 4
    output:
        out = config['ccre']['intersect']
    run:
        intersect_ccre(input.ccre,
                       input.files,
                       output.out)
